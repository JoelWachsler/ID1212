{"version":3,"sources":["../../src/game/snake.js"],"names":["UP","RIGHT","DOWN","LEFT","Snake","constructor","id","point","head","body","direction","bodyPartsToAdd","applyMovement","length","push","pop","i","x","y","changeMovement","newDirection","current","isColliding","colliding","isCollidingWithFood","food","foodPoints","map","collissionIndex","findIndex","splice","addBodyPart","isCollidingWithPoints","points","collidingMany"],"mappings":";AACA;AACA;AACA;AACA;AACA,sD,8FALA;;AAOA;AACA,MAAMA,KAAK,CAAX;AACA,MAAMC,QAAQ,CAAd;AACA,MAAMC,OAAO,CAAb;AACA,MAAMC,OAAO,CAAb;;AAEA;;;AAGe,MAAMC,KAAN,4BAA8B;AAC3C;;;;;AAKAC,cAAYC,EAAZ,EAAgBC,KAAhB,EAAuB;AACrB;;AAEA,SAAKD,EAAL,GAAUA,EAAV;AACA,SAAKE,IAAL,GAAYD,KAAZ;AACA,SAAKE,IAAL,GAAY,CAAC,KAAKD,IAAN,CAAZ;AACA,SAAKE,SAAL,GAAiBT,KAAjB;;AAEA;AACA,SAAKU,cAAL,GAAsB,EAAtB;AACD;;AAED;;;;;AAKAC,kBAAgB;AACd;AACA,QAAI,KAAKD,cAAL,CAAoBE,MAApB,GAA6B,CAAjC;AACE,SAAKJ,IAAL,CAAUK,IAAV,CAAe,KAAKH,cAAL,CAAoBI,GAApB,EAAf;;AAEF;AACA,SAAK,IAAIC,IAAI,KAAKP,IAAL,CAAUI,MAAV,GAAmB,CAAhC,EAAmCG,IAAI,CAAvC,EAA0CA,GAA1C,EAA+C;AAC7C,YAAM,EAAEC,CAAF,EAAKC,CAAL,KAAW,KAAKT,IAAL,CAAUO,IAAI,CAAd,CAAjB;AACA,WAAKP,IAAL,CAAUO,CAAV,IAAe,mBAAUC,CAAV,EAAaC,CAAb,CAAf;AACD;;AAED,YAAQ,KAAKR,SAAb;AACE,WAAKV,EAAL;AACE,aAAKQ,IAAL,CAAUU,CAAV;AACA;AACF,WAAKjB,KAAL;AACE,aAAKO,IAAL,CAAUS,CAAV;AACA;AACF,WAAKf,IAAL;AACE,aAAKM,IAAL,CAAUU,CAAV;AACA;AACF,WAAKf,IAAL;AACE,aAAKK,IAAL,CAAUS,CAAV;AACA,cAZJ;;AAcD;;AAED;;;;;;;AAOAE,iBAAeC,YAAf,EAA6B;AAC3B,UAAMC,UAAU,KAAKX,SAArB;;AAEA,YAAQU,YAAR;AACE,WAAKpB,EAAL;AACE,YAAIqB,WAAWnB,IAAf,EAAqB,KAAKQ,SAAL,GAAiBV,EAAjB;AACrB;AACF,WAAKC,KAAL;AACE,YAAIoB,WAAWlB,IAAf,EAAqB,KAAKO,SAAL,GAAiBT,KAAjB;AACrB;AACF,WAAKC,IAAL;AACE,YAAImB,WAAWrB,EAAf,EAAmB,KAAKU,SAAL,GAAiBR,IAAjB;AACnB;AACF,WAAKC,IAAL;AACE,YAAIkB,WAAWpB,KAAf,EAAsB,KAAKS,SAAL,GAAiBP,IAAjB;AACtB,cAZJ;;AAcD;;AAED;;;;;;AAMAmB,cAAYf,KAAZ,EAAmB;AACjB,WAAO,MAAMgB,SAAN,CAAgB,KAAKf,IAArB,EAA2BD,KAA3B,CAAP;AACD;;AAED;;;;;;AAMAiB,sBAAoBC,IAApB,EAA0B;AACxB,UAAMC,aAAaD,KAAKE,GAAL,CAASF,QAAQA,KAAKlB,KAAtB,CAAnB;AACA,UAAMqB,kBAAkBF,WAAWG,SAAX,CAAqBJ,QAAQ,KAAKH,WAAL,CAAiBG,IAAjB,CAA7B,CAAxB;;AAEA,QAAIG,oBAAoB,CAAC,CAAzB,EAA4B;;AAE5BH,SAAKK,MAAL,CAAYF,eAAZ,EAA6B,CAA7B;AACA,SAAKG,WAAL;AACD;;AAED;;;;;AAKAC,wBAAsBC,MAAtB,EAA8B;AAC5B,WAAO,MAAMC,aAAN,CAAoB,KAAK1B,IAAzB,EAA+ByB,MAA/B,CAAP;AACD;;AAED;;;;;AAKAF,gBAAc;AACZ,SAAKpB,cAAL,CAAoBG,IAApB,CAAyB,mBAAU,KAAKN,IAAL,CAAUS,CAApB,EAAuB,KAAKT,IAAL,CAAUU,CAAjC,CAAzB;AACD,GAtH0C,C","file":"snake.js","sourcesContent":["// @ts-check\nimport Point from \"./point\";\nimport Colliding from \"./colliding\";\nimport { SIZE } from \"../common/constants\";\nimport Controller from \"../controller/controller\";\nimport Food from \"./food\";\n\n// Different directions\nconst UP = 0;\nconst RIGHT = 1;\nconst DOWN = 2;\nconst LEFT = 3;\n\n/**\n * An instance of a snake.\n */\nexport default class Snake extends Colliding {\n  /**\n   * @param {string} id\n   * @param {Point} point\n   * @api public\n   */\n  constructor(id, point) {\n    super();\n\n    this.id = id;\n    this.head = point;\n    this.body = [this.head];\n    this.direction = RIGHT;\n\n    // Body parts to be added on the next tick.\n    this.bodyPartsToAdd = [];\n  }\n\n  /**\n   * Moves the snake head and body to the current direction.\n   *\n   * @api public\n   */\n  applyMovement() {\n    // Add new body parts if there are any\n    if (this.bodyPartsToAdd.length > 0)\n      this.body.push(this.bodyPartsToAdd.pop());\n\n    // Move the body parts\n    for (let i = this.body.length - 1; i > 0; i--) {\n      const { x, y } = this.body[i - 1];\n      this.body[i] = new Point(x, y);\n    }\n\n    switch (this.direction) {\n      case UP:\n        this.head.y -= SIZE;\n        break;\n      case RIGHT:\n        this.head.x += SIZE;\n        break;\n      case DOWN:\n        this.head.y += SIZE;\n        break;\n      case LEFT:\n        this.head.x -= SIZE;\n        break;\n    }\n  }\n\n  /**\n   * Change the direction of the snake.\n   * Checks if the current direction is not in the opposite way of the head.\n   *\n   * @param {number} newDirection\n   * @api public\n   */\n  changeMovement(newDirection) {\n    const current = this.direction;\n\n    switch (newDirection) {\n      case UP:\n        if (current != DOWN) this.direction = UP;\n        break;\n      case RIGHT:\n        if (current != LEFT) this.direction = RIGHT;\n        break;\n      case DOWN:\n        if (current != UP) this.direction = DOWN;\n        break;\n      case LEFT:\n        if (current != RIGHT) this.direction = LEFT;\n        break;\n    }\n  }\n\n  /**\n   * Checks if the snake head is colliding with the provided point.\n   *\n   * @param {Point} point The points to check if the head is colliding with.\n   * @api public\n   */\n  isColliding(point) {\n    return super.colliding(this.head, point);\n  }\n\n  /**\n   * Check if this snake is colliding with the provided piece of food.\n   * \n   * @param {Food[]} food\n   * @api public\n   */\n  isCollidingWithFood(food) {\n    const foodPoints = food.map(food => food.point);\n    const collissionIndex = foodPoints.findIndex(food => this.isColliding(food));\n\n    if (collissionIndex === -1) return;\n\n    food.splice(collissionIndex, 1);\n    this.addBodyPart();\n  }\n\n  /**\n   * Check if this snake is colliding with a wall.\n   *\n   * @api public\n   */\n  isCollidingWithPoints(points) {\n    return super.collidingMany(this.head, points);\n  }\n\n  /**\n   * Adds a body part the next game tick.\n   *\n   * @api public\n   */\n  addBodyPart() {\n    this.bodyPartsToAdd.push(new Point(this.head.x, this.head.y));\n  }\n}\n"]}